CREATE TABLE TEST_TBL (
    ID      NUMBER(5)       PRIMARY KEY ,
    NAME    VARCHAR2(50)    NOT NULL,
    ADDRESS VARCHAR2(100),
    REGDATE DATE            DEFAULT SYSDATE
);

SELECT  *
FROM    TEST_TBL;

DROP TABLE TEST_TBL;

INSERT INTO TEST_TBL 
VALUES(100, 'XIANG', NULL, NULL) ;

INSERT INTO TEST_TBL (ID, NAME, ADDRESS)
VALUES (200,'MIN',NULL);

CREATE  TABLE   TEST_PARENT(
    DEPT_ID     NUMBER(5)       PRIMARY KEY,
    DEPT_NAME   VARCHAR2(50)    DEFAULT 'NEW'
);

CREATE  TABLE   TEST_CHILD(
    EMP_ID      NUMBER(5)       PRIMARY KEY,
    DEPT_ID     NUMBER(5)       REFERENCES TEST_PARENT(DEPT_ID),
    SALARY      NUMBER(10)      CHECK (SALARY > 0)
);

SELECT  *
FROM    TEST_PARENT;

SELECT  *
FROM    TEST_CHILD;

INSERT INTO TEST_PARENT 
VALUES (10,'기획');
INSERT INTO TEST_PARENT
VALUES (20,'데이터전담');

INSERT INTO TEST_CHILD
VALUES (100, 20, 100);

CREATE  TABLE TEST_PARENT2(
    P_ID    NUMBER(5) ,
    P_NAME  VARCHAR2(50),
    PRIMARY KEY (P_ID, P_NAME)
);

INSERT INTO TEST_PARENT2
VALUES (10, 'XIANG');
INSERT INTO TEST_PARENT2
VALUES (20, 'MIN');


CREATE TABLE TEST_CHILD2(
    C_ID    NUMBER(5)   PRIMARY KEY,
    P_ID    NUMBER(5) ,
    P_NAME  VARCHAR(50),
    C_NUM   NUMBER(10)  CHECK ( C_NUM > 0),
    FOREIGN KEY (P_ID, P_NAME) REFERENCES TEST_PARENT2(P_ID, P_NAME)
);

CREATE TABLE TEST_CHILD3(
    C_ID    NUMBER(5) ,
    P_ID    NUMBER(5) ,
    P_NAME  VARCHAR(50),
    C_NUM   NUMBER(10)  CHECK ( C_NUM > 0),
    FOREIGN KEY (P_ID, P_NAME) REFERENCES TEST_PARENT2(P_ID, P_NAME),
    PRIMARY KEY (C_ID, P_ID, P_NAME)
);

INSERT INTO TEST_CHILD2 
VALUES (100, 10,'XIANG', 9306);

INSERT INTO TEST_CHILD3
VALUES (100,10,'XIANG',9306);
INSERT INTO TEST_CHILD3
VALUES (100,10,'MIN',9306);

-- CREATE 구문에 서브쿼리 사용이 가능하다
/* CREATE TABLE <TABLE_NAM>
AS SUBQUERY ; 
*/
CREATE TABLE TEST_SUBQUERY2
AS  SELECT   EMP_ID, EMP_NAME, NVL(BONUS_PCT, 0) BN
    FROM     EMPLOYEE;
-- 함수적용 컬럼은 별칭을 주어야 한다. 
-- 혹은 별도로 컬럼명을 명명해줘야한다.
SELECT  *
FROM TEST_SUBQUERY2;

-- VIEW (VIRTUAL TABLE)
-- DML 작업 불가
/*
CREATE OR REPLACE VIEW <VIEW_NAME>
AS SUBQUERY*/
CREATE OR REPLACE VIEW DEPT90
AS   SELECT  EMP_ID, EMP_NAME, EMAIL, JOB_ID, MGR_ID, DEPT_ID
     FROM    EMPLOYEE
     WHERE   DEPT_ID = '90';

SELECT  *
FROM    DEPT90;

DROP VIEW DEPT90;

-- CREATE OR REPLACE > VIEW는 논리적이기 때문에 덮어쓰기가 가능하다.
-- 뷰 이름이 겹친다면 새로 만드는 뷰가 기존 뷰를 대체한다.

CREATE OR REPLACE VIEW HIREDATE20
AS  SELECT  HIRE_DATE ,
            TRUNC(MONTHS_BETWEEN(SYSDATE , HIRE_DATE) / 12) AS 근속년수    
    FROM    EMPLOYEE 
    WHERE   MONTHS_BETWEEN(SYSDATE , HIRE_DATE) > 240 ;

SELECT  *
FROM    HIREDATE20;

DROP VIEW HIREDATE20;

-- TOP-N 분석
-- INLINE VIEW를 통한 TOP-N 분석
-- 슈도?컬럼 : ROWNUM, ROWID 라는 컬럼이 존재함 (구조상)
SELECT  ROWNUM, ROWID, EMP_ID
FROM    EMPLOYEE;

-- 부서별 평균 급여보다 많은 급여를 받는 직원의 이름, 급여를 조회
-- INLINE VIEW
SELECT  ROWNUM, EMP_NAME, SALARY
FROM    (SELECT  E.EMP_NAME, E.SALARY, 
                 E.DEPT_ID, DS.AVSAL
         FROM    EMPLOYEE E
         JOIN    (  SELECT  DEPT_ID, ROUND(AVG (SALARY),-3) AVSAL
                    FROM    EMPLOYEE
                    GROUP BY DEPT_ID) DS ON(E.DEPT_ID = DS.DEPT_ID)
                    WHERE   E.SALARY > DS.AVSAL
                    ORDER BY 2 DESC)
WHERE   ROWNUM <= 5;                    


-- 처음 쿼리문을 작성했을때는 SALARY에 맞는 ROWNUM이 아님
-- 가져온 결과에 대해 SORTING(ORDERBY)는 의미없음
-- 결과에 ROWNUM을 부여하는 방식을 사용해야 한다.
-- ROWNUM의 1이 아닌 다른 숫자들은 식별 불가능 하지만, 범위검색은 가능
-- 따라서 ORDER BY, 정렬까지 된 테이블을 인라인 뷰로, 그리고 이것을 다시 사용해서 ROWNUM을 이용해서 추출한다.


-- SEQUENCE 시퀀스 : AUTOINCREMENT
/*
-- NEXTVAL, CURVAL
CREATE SEQUENCE <SEQUENCE_NAME> ;
<OPTION> - INCREMENT, SATRT_WITH, MAXVALUE, MINVALUE, CYCLE, CACHE
*/

CREATE SEQUENCE TESTSEQ;
SELECT  TESTSEQ.NEXTVAL FROM DUAL;
SELECT  TESTSEQ.CURRVAL FROM DUAL;

INSERT INTO TEST_CHILD3 VALUES (TESTSEQ.NEXTVAL, 10, '임섭순' ,2000);

/* -- DML
UPDATE  TABLE_NAME
SET     COL_NAME = VALUE, ...
WHERE   CONDITION ;
--> VALUE로 특정값은 물론 SUBQUERY사용 가능

DELETE  TABLE_NAME
WHERE   CONDTION;
*/

SELECT  *
FROM    DEPARTMENT;

UPDATE  DEPARTMENT
SET     DEPT_NAME = '전략기획팀'
WHERE   DEPT_ID = 30;

CREATE  TABLE DELETE_TBL
AS  SELECT  *
    FROM    DEPARTMENT;
    
SELECT  *
FROM    DELETE_TBL;

DELETE  FROM    DELETE_TBL
WHERE   DEPT_ID = '30';