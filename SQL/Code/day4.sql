-- GROUP BY
-- GROUP BY COLUMN NAME | EXPR --> 주민번호를 이용해서 성별을 추출 하는 등 가능
-- GROUP BY가 사용되면 SELECT 절에 일반속성 사용불가, 
-- GROUP BY에 명세된 컬럼은 사용 가능 (컬럼 이름만 사용 가능)

-- 성별에 따른 평균 임금
SELECT  CASE SUBSTR(EMP_NO,8,1) WHEN '1' THEN '남' ELSE '여' END AS 성별,
        ROUND(AVG(SALARY),4)
FROM    EMPLOYEE
GROUP BY ROLLUP(CASE SUBSTR(EMP_NO,8,1)WHEN '1' THEN '남' ELSE '여' END);

-- ROLLUP은 첫번째 컬럼을 기준으로 중간중간 소계가 나온다(COMPOSIT일 경우)

SELECT      DEPT_ID,
            EMP_NAME,
            COUNT(*)
FROM        EMPLOYEE
GROUP BY    ROLLUP(DEPT_ID, EMP_NAME)
ORDER BY    1;

SELECT      SUBSTR(TERM_NO, 1, 4) 년도,
            SUBSTR(TERM_NO, 5, 2) 학기,
            ROUND(AVG(POINT),1) 평점
FROM        TB_GRADE
WHERE       STUDENT_NO = 'A112113'
GROUP BY    ROLLUP( SUBSTR(TERM_NO,1,4), SUBSTR(TERM_NO,5,2) );

SELECT      DEPT_ID, SUM(SALARY)
FROM        EMPLOYEE
GROUP BY    DEPT_ID
HAVING      SUM(SALARY) > 9000000;

-- 1. WHERE절에 GROUP 함수를 사용할 수 없다.
SELECT      DEPT_ID, SUM(SALARY)
FROM        EMPLOYEE
WHERE       SUM(SALARY) > 9000000
GROUP BY    DEPT_ID;

-- 분석함수() OVER(PARTITION BY, ORDER BY), 
-- 레코드의 변환 없이 통계값 확인
-- ROW_NUMBER() : ORDERBY는 PARTITION에 명시되지 않은 열도 가능


-- RANK(), DENSE_RANK()
SELECT  DEPT_ID,
        EMP_NAME,
        SALARY,
        DENSE_RANK() OVER(PARTITION BY DEPT_ID ORDER BY SALARY DESC) "RANK"
FROM    EMPLOYEE;

-- 분포 확인 CUME_DIST 상대적 누적 분포
-- 백분율은 PERCENT_RANK() 백분율 순위


SELECT  *
FROM    SAL_GRADE;

SELECT *
FROM   DEPARTMENT;

SELECT  EMP_NAME,
        DEPT_NAME
FROM    EMPLOYEE E, DEPARTMENT D
WHERE   E.DEPT_ID = D.DEPT_ID;
-- ANSI 표준 USING, ON 
-- ON은 조건 식을 사용 가능, USING은 컬럼만 기술 가능 
-- USING: 부모의 기본키와 자식의 외부키가 동일할 경우

SELECT  EMP_NAME,
        DEPT_NAME
FROM    EMPLOYEE E
JOIN    DEPARTMENT D USING(DEPT_ID);

SELECT  EMP_NAME,
        DEPT_NAME,
        LOC_DESCRIBE,
        COUNTRY_NAME
FROM    EMPLOYEE E 
JOIN    DEPARTMENT D USING(DEPT_ID)
JOIN    LOCATION L ON (L.LOCATION_ID = D.LOC_ID)
JOIN    COUNTRY C USING(COUNTRY_ID);

-- ORACLE형 JOIN구문을 사용하면, SELECT 절에서 별칭을 명시안하면 모호성 오류 발생
-- USING에서는 별칭을 사용하지 않고, SELECT절에서도 별칭을 명시하지 않아도 된다.

SELECT  EMP_NAME,
-- ORACLE JOIN을 사용할경우, 별칭X -> 모호성 오류 발생
        DEPT_ID
        DEPT_NAME
FROM    EMPLOYEE E, DEPARTMENT D
WHERE   E.DEPT_ID = D.DEPT_ID ;

SELECT  EMP_NAME,
        DEPT_NAME,
        DEPT_ID
-- ANSI표준 JOIN은 따로 별칭을 명시하지 않아도 가능하다.
FROM    EMPLOYEE E
JOIN    DEPARTMENT D USING(DEPT_ID);

/* OUTER JOIN 
누락된 데이터까지 포함! 
LEFT | RIGHT | FULL  JOIN ~ ON(조건식)
LEFT | RIGHT | FULL  JOIN ~ USING(기준컬럼)
*/

SELECT  EMP_NAME,
        DEPT_NAME
FROM    EMPLOYEE E
FULL JOIN DEPARTMENT D USING (DEPT_ID);

-- SELF RECURSIVE JOIN
SELECT  E.EMP_NAME,
        M.EMP_NAME
FROM EMPLOYEE E
LEFT JOIN EMPLOYEE M ON(E.MGR_ID = M.EMP_ID);

SELECT  E.EMP_NAME,
        M.EMP_NAME
FROM EMPLOYEE E
JOIN EMPLOYEE M ON(E.MGR_ID = M.EMP_ID);

-- 직원 급여등급을 알아보려고 한다.
-- SAL_GRADE 테이블을 참조 이름, 급여, 급여등급 (SLEVEL)

-- ORACLE
SELECT  EMP_NAME 사원명,
        SALARY  급여,
        SLEVEL 급여등급
FROM    EMPLOYEE E, SAL_GRADE SG
WHERE   E.SALARY BETWEEN SG.LOWEST AND HIGHEST;

-- ANSI표준
SELECT  EMP_NAME 사원명,
        SALARY  급여,
        SLEVEL 급여등급
FROM    EMPLOYEE E
JOIN    SAL_GRADE SG ON (E.SALARY BETWEEN SG.LOWEST AND SG.HIGHEST);

-- 교과서 최종 예제
SELECT  E.EMP_NAME 사원명,
        J.JOB_TITLE 직급,
        D.DEPT_NAME 부서,
        L.LOC_DESCRIBE 지역,
        C.COUNTRY_NAME 국가,
        SG.SLEVEL 급여등급
FROM    EMPLOYEE E
LEFT JOIN    JOB J USING(JOB_ID)
LEFT JOIN    DEPARTMENT D USING(DEPT_ID)
LEFT JOIN    LOCATION L ON(D.LOC_ID = L.LOCATION_ID)
LEFT JOIN    COUNTRY C USING(COUNTRY_ID)
LEFT JOIN    SAL_GRADE SG ON (E.SALARY BETWEEN SG.LOWEST AND SG.HIGHEST)
ORDER BY    SG.SLEVEL;